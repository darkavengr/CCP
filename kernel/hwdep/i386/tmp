size_t page_init(size_t process) {
struct ppt *last;
uint32_t save_virtual_address;
uint32_t pagedir_virtual_address;
uint32_t save_physical_address;
uint32_t pagedir_physical_address;
size_t count;
size_t size;

if(process == 0) return;		/* don't need to intialize if process 0 */

/* Get a physical address and manually map it to a virtual address. The physical addres of p->pagedir is needed to fill cr3 */

size=(sizeof(struct ppt) & ((0-1)-(PAGE_SIZE-1)))+PAGE_SIZE;		/* round */

pagedir_physical_address=kernelalloc_nopaging(size);					/* add link */
if(pagedir_physical_address == NULL) return(-1);

pagedir_virtual_address=findfreevirtualpage(size,ALLOC_KERNEL,0);		/* find free virtual address */

save_virtual_address=pagedir_virtual_address;
save_physical_address=pagedir_physical_address;

for(count=0;count<(size/PAGE_SIZE)+1;count++) {
	addpage_system(pagedir_virtual_address,0,(void *) pagedir_physical_address);

	pagedir_physical_address += PAGE_SIZE;
	pagedir_virtual_address += PAGE_SIZE;
}

/* Important: make sure that is processpaging_end == processpaging. This most be done in the paging intialization code */

if(processpaging_end == NULL) processpaging_end=processpaging; /* do it anyway */

processpaging_end->next=save_virtual_address;					/* add link to list */
processpaging_end=processpaging_end->next;		/* point to end */
processpaging_end->pagedirphys=save_physical_address;						/* physical address of page directory */
processpaging_end->process=process;

/* add bottom half PDPTs */

for(count=0;count != 2;count++) {
	pagedir_physical_address=kernelalloc_nopaging(PAGE_SIZE);
	if(pagedir_physical_address == NULL) return(-1);

	last->pdpt[count]=pagedir_physical_address | PAGE_PRESENT;

	addpage_system(pagedir_physical_address+KERNEL_HIGH,0,(void *) pagedir_physical_address);
}

last->pdpt[2]=processpaging->pdpt[2];		/* copy top-half PDPT */
last->pdpt[3]=save_physical_address | PAGE_PRESENT;		/* map last PDPT to PDPT */

last->next=NULL;
return;
}

